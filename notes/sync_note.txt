Увага!
Синхронизация - приведение информации об объекте в актуальное состояние
Синхронизация имеет смысл только в контексте всей системы
Важно отделить синхронизацию объектов от их загрузки (ввод всей информации с нуля)
---------------------------------------------
Дата синхронизации, дата ревизии и дата обновления (!!!)
    * last_sync - когда последний раз сверялись с оригиналом
    * last_update - когда последний раз обновлялся оригинал
    * last_revision - когда последний раз пересчитывали связи
last_update > last_revision - связи нужно пересчитать
---------------------------------------------
Зависимости объекта надо подтягивать не входящие, а исходящие ->>>
    Предположим, что мы синхронизируем таблицу, она не изменилась, 
    следовательно, зависимости не пересмотрены, если появилась новая 
    зависимость (в новой или имеющейся процедуре), то алгоритм её не увидит.
Хранящиеся в системе скульные зависимости должны иметь галку is_checked ->>>
    или что-то вроде того, показывающую, что данная зависимость проверена 
    алгоритмом поиска и соответствующая ей связь находится в актуальном состоянии.
При обновлении зависимостей во время синхронизации надо снимать галку
У компонентов delphi должно быть поле с контрольной суммой  ->>>
    метод, чистящий sql должен быть перенесён в синхронизацию из моделей;
    сравнение контрольных сумм компонентов необходимо, т.к. нет иного способа определить,
    изменялся ли он, компонент существует внутри формы, а форму можно изменить, не затрагивая
    компоненты, например, переставив гриды/надписи или что-то ещё;
    изменения компонентов нужно тщательно контролировать, избегая ненужных обновлений, так как
    анализ связей компонентов дорого обходится (приходится перебирать все объекты БД)
Из баз тащим исходящие связи, а при анализе запросов строим входящие ->>>
    Исходящие связи идут от скриптов к объектам, которые они вызывают, а входящие - наборот;
    Мы не знаем ничего о зависимостях компонентов Delphi, каждый из них придётся проверять 
    на вхождение всех таблиц, процедур и остального, каждый проверяемый объект - одна большая 
    регулярка, итого много проверок, большинство из которых сработают вхолостую.
    Сначала итерируемся по объектам К КОТОРЫМ мы проводим связи (таблицы), а потом по скриптам,
    чтобы не вызывать метод генерации регулярки X*Y раз
Какая разница между last_update & last_sync? ->>>
    Если объект был изменён и обновлён после этого, то эти даты совпадают;
    Есть вариант проставлять всем объектам новый last_sync каждый раз, когда они
    проходят синхронизацию.
    Сейчас last_sync автоматом проставляется для любой ноды при вызове update_from()
Возможность добавления объектов вручную - ???
Частичное обновление - ???
Получается, что частичная синхронизация не имеет смысла ->>>
    например пересчёт связей таблицы подталкивает к тому, чтобы обновить
    все недавно обновлённые скрипты, а их тоже неплохо бы обновить, а у них ещё и свои связи и т.д.
Отделение синхронизации от построения связей ->>>
    Если делать всё сразу, то всё очень долго считается (27 баз, тысячи запросов)
    Затруднённость точечного обновления;
    Построение связей от загрузки надо отделить ещё и потому, что 
    у соединений Delphi надо вручную прописывать базу, после того, как они были загружены.
    Понятие загрузки и его отдельность от синхронизации.
---------------------------------------------

Полная синхронизация всей системы
Обходим все базы
    сопоставляем списки объектов
        есть в системе, нет в оригинале - удалить
        нет в системе, есть в оригинале - добавить
        есть и там, и там - если объект изменился (дата съехала), то обновить
            данные самого объекта и, если это скрипт, обновить его зависимости
        обновление зависимостей
            достаём оригиналы из системных таблиц
            сверяем с зависимостями из системы
            удаляем удалённые, вставляем новые, снимаем галки у имеющихся

Обходим АРМы, смотрим новые и удалённые формы (для этого лезем в файл проекта), смотрим формы 
с датой обновления больше, чем в системе;


Обновление связей

Для скриптов в базе нужны только те объекты, которые есть у них в зависимостях, для скриптов 
на клиенте нужны все объекты, потому что заранее зависимости неизвестны.

При анализе связей нужно как можно сильнее уменьшить количество перебираемых объектов и 
их переборов.

Получаем список скриптов, у которых синхронизация прошла, а анализа не было (last_update > last_revision)
    При этом системные зависимости и исходящие связи тоже подтягиваем
Выбираем компоненты, хранящие сырой sql, у которых last_update > last_revision или last_revision не указана, 
    подтягиваем Connection, чтобы иметь доступ к id базы данных
    Исходящие связи тоже тащим
Тащим все DatabaseObject'ы из всех баз (иначе не сможем проверить компоненты) ->>>
    если компонентов с изменениями нет, то можно подтянуть не все объекты, а только те, которые есть 
    в зависимостях изменившихся скриптов
Перебираем объекты
    Генерируем 2 регулярки: 1 для родной базы и 1 для всех остальных
    Перебираем компоненты и скрипты
        если (это скрипт и объект есть у него в зависимостях) или это компонент
            то проверяем одной или другой регуляркой в зависимости от того, какая база
            считаем циферки
            смотрим исходящие связи скрипта/компонента,
                если связи нет - создали, есть - перезаписали циферки
            если это скрипт - поставли галку в системной зависимости

Таблица
	Если оригинал отсутствует
		Удалить ноду
	Поставить дату обновления таблицы
	Вытащить сохранённые системные зависимости
	Вытащить оригинальные системные зависимости
	Сопоставить зависимости - создать новые, удалить ненужные; имеющиеся обновлять нет смысла;
	Пересчёт связей
		Смотрим все клиентские компоненты
		Смотрим новые системные зависимости
		Смотрим те скрипты, которые зависят от таблицы и были недавно изменены