Анализ токенов

Служебные символы
< - открывает последовательность item'ов
> - закрывает последовательность item'ов
[ - открывает последовательность констант
] - закрывает последовательность констант
( - открывает последовательность чисел/строк
) - закрывает последовательность чисел/строк
{ - открывает бинарную последовательность
} - закрывает бинарную последовательность
, - сейчас будет новый член последовательности [] (в других последовательностях запятая не используется)
: - сейчас будет тип данных объекта
= - сейчас будет значение свойства
' - начало/конец строкового литерала (явный)
+ - обрезка строки в многострочном тексте

Вложенных последовательностей не бывает;
Любой из вышеуказанных символов (в т.ч. кавычка) не является служебным, если заключён в кавычки;
если нашли такой токен, то надо убедиться, что эта кавычка - первая в строке, тогда читаем значение до последней кавычки в строке и формируем токен из этого значения.

Ключевые слова
object
item
end

Остальное
<идентификатор> - имя объекта, имя свойства, название типа, строковый литерал без кавычек; при чтении трансформируется в строковый литерал с кавычками (propertyName -> "properyName")
+-<число> (впереди максимум 1 знак, запрещены ведущие нули)
Логическое значение (true/false, регистр не важен, приведём к одному)

Вариант алгоритма:
Дошли до непробельного символа;
читаем его;
если служебный, возвращаем токен;
иначе смотрим до пробела/конца строки;
если это ключевое слово, возвращаем соответствующий токен (объект со всеми потрохами обрабатываем за раз?);
если это что-то другое
проверяем на число, на идентификатор, на логическое значение;

иначе ошибка - неизвестный токен.

Движение по токенам
-----------------------------------------------
При чтении данных находим некий токен, это переводит парсер в новое состояние, 
в результате чего при следующем чтении токена парсер ожидает найти токены 
определённого типа, например, если мы находимся в состоянии парсинга объекта, 
то мы ожидаем увидеть имя объекта, если мы находимся в состоянии парсинга 
содержимого объекта, то мы ожидаем найти либо вложенный объект, либо имя 
свойства и т.д. При отступлении от этого кидаем ошибку - "X expected, Y found".

Как работать с токенами
-----------------------------------------------
if ch == ?? and self.check_some_conditions:
    return self.fetch_some_token()

Кавычки
' - заводим переменную in_quoted_string -> boolean, которая равна True, если мы
находимся внутри закавыченной строки; если найденный символ - кавычка, чекаем
эту переменную, если False, значит мы нашли новую строчку, достаём её.

Извлечение строки в кавычках
ползём по символам, нашли кавычку, смотрим, не является ли она последней в строке: 
count_quotes_in_line() == 0 (от текущей позиции идём вперёд и считаем кавычки,
пока не дойдём до конца строки), если ноль, значит, эта кавычка последняя, копируем
значение в буфер. Если до конца строки не нашли кавычку, гавкаем на ошибку.

Когда строка закончена, ставим in_quoted_string = Fale. 

Скобки
Все три типа скобок служат для совершенно разных целей и содержат токены, 
которые нужно по-разному интерпретировать.
Последовательности в круглых скобках и свойство Strings (многострочный текст) будем 
интерпретировать одинаково.

in_const_sequence, check_const_sequence
Переменная переводится в True, когда находим [; если нашли ], и True, то переводим в False;
метод проверяет это и чекает, чтобы мы были не в кавычках;
in_item_sequence, check_item_sequence - <>
in_scalar_sequence, check_scalar_sequence - ()
in_binary_sequence, check_binary_sequence - {}
Может быть, метод лишний и проверка на кавычки тоже.

Сложение разбитых строк

Знак + обрабатыается как самостоятельный токен, его наличие говорит о том, что следующая
строка должна прицепиться к предыдущей, когда парсер (или кто там) будет собирать
из токенов структуры данных.

Русские буквы
В некоторых местах делфи кодирует русские буквы как #<код символа в utf-8>
В многострочниках это выглядит ещё интереснее - когда строка обрезается на русских буквах 
(например, на комментарии или алиасе поля таблицы), то делфи кодирует все символы, 
в т.ч. закрывающую кавычку, превращая её в #39. Потом, как ни в чём ни бывало, идёт знак + 
и переход на другую строку.
Кавычка в кавычках в запросе - пробел выглядит так - '#39'пробел'#39' - на выходе должно быть ' '

Для обработки русских букв используем ранее написанный код - всё-таки это скорее баг, 
чем фича.

Не всякий токен генерирует событие парсера, а только те, которые несут значимую информацию. Например, если мы парсим заголовок
объекта, то при нахождении токена двоеточия мы не кидаем событие, а начинаем парсить тип данных объекта, а когда достанем 
его - вот тогда и кинем событие.
