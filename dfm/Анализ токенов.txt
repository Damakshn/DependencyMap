Анализ токенов

Служебные символы
< - открывает последовательность item'ов
> - закрывает последовательность item'ов
[ - открывает последовательность констант
] - закрывает последовательность констант
( - открывает последовательность чисел/строк
) - закрывает последовательность чисел/строк
, - сейчас будет новый член последовательности [] (в других последовательностях запятая не используется)
: - сейчас будет тип данных объекта
= - сейчас будет значение свойства
' - начало/конец строкового литерала (явный)

Вложенных последовательностей не бывает;
Любой из вышеуказанных символов (в т.ч. кавычка) не является служебным, если заключён в кавычки;
если нашли такой токен, то надо убедиться, что эта кавычка - первая в строке, тогда читаем значение до последней кавычки в строке и формируем токен из этого значения.

Ключевые слова
object
item
end

Остальное
<идентификатор> - имя объекта, имя свойства, название типа, строковый литерал без кавычек; при чтении трансформируется в строковый литерал с кавычками (propertyName -> "properyName")
+-<число>
Логическое значение

Вариант алгоритма:
Дошли до непробельного символа;
читаем его;
если служебный, возвращаем токен;
иначе смотрим до пробела/конца строки;
если это ключевое слово, возвращаем соответствующий токен (объект со всеми потрохами обрабатываем за раз?);
если это что-то другое
проверяем на число, на идентификатор, на логическое значение;

иначе ошибка - неизвестный токен.

Движение по токенам
-----------------------------------------------
При чтении данных находим некий токен, это переводит парсер в новое состояние, в результате чего при следующем чтении токена парсер ожидает найти токены определённого типа, например, если мы находимся в состоянии парсинга объекта, то мы ожидаем увидеть имя объекта, если мы находимся в состоянии парсинга содержимого объекта, то мы ожидаем найти либо вложенный объект, либо имя свойства и т.д. При отступлении от этого кидаем ошибку - "X expected, Y found"